"use client";

import { useEffect, useRef, useState, useCallback, useMemo, memo, FC, ChangeEvent } from "react";
import { X, AlertCircle, RotateCcw, RefreshCcw, Palette as PaletteIcon } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Card, CardContent } from "@/components/ui/card";
import { ChartResultContent, ChartType } from "@/types";
import { EnhancedChart } from "@/components/charts/enhanced-chart";
import { useChartExport, useChartExportStatus } from "@/contexts/chart-export-context";
import { ChartThemeProvider, useChartTheme } from "@/contexts/chart-theme-context";
import { useToast } from "@/components/ui/use-toast";
import { Input } from "@/components/ui/input";
import { chartExportService } from "@/services/chart-export-service";
import { normalizeHexColor, applyPaletteToConfig } from "@/lib/colors";
import { globalChartManager } from "@/lib/global-chart-manager";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ENHANCED_CHART_DEFAULTS } from "@/components/charts/enhanced-chart/types";
import { CHART_TYPE_LABELS } from "@/constants/chart";
import type { LineDotVariant } from "@/components/charts/line-chart/types";
import type { ChartPalette } from "@/types";

// --- REFACTORED TYPES AND CONSTANTS ---

const HEX_INPUT_PATTERN = /^#?([0-9a-f]{3}|[0-9a-f]{6})$/i;
const BAR_RADIUS_MAX = 24;
const LINE_DOT_VARIANTS: Array<{ value: LineDotVariant; label: string }> = [
  { value: "default", label: "Default" },
  { value: "solid", label: "Solid" },
  { value: "icon", label: "Icon" },
];

type ChartOptionState = {
  barRadius?: number;
  barShowValues?: boolean;
  barShowGrid?: boolean;
  lineCurveType?: "monotone" | "linear";
  lineShowDots?: boolean;
  lineDotSize?: number;
  lineDotVariant?: LineDotVariant;
  lineShowGrid?: boolean;
  areaFillOpacity?: number;
  areaStacked?: boolean;
  areaUseGradient?: boolean;
  areaShowGrid?: boolean;
  innerRadius?: number;
  outerRadius?: number;
  showPercentage?: boolean;
  showLegend?: boolean;
  radialInnerRadius?: number;
  radialOuterRadius?: number;
  radialBarSize?: number;
  radialCornerRadius?: number;
  radialShowBackground?: boolean;
  radialShowLabels?: boolean;
  radarShowArea?: boolean;
  radarShowDots?: boolean;
  radarShowGrid?: boolean;
  radarShowLegend?: boolean;
  radarFillOpacity?: number;
  radarStrokeWidth?: number;
};

interface ChartDisplayAreaProps {
  chart: ChartResultContent | null;
  onClose: () => void;
  onUpdateChart?: (chart: ChartResultContent) => void;
}

type CustomPalette = Omit<
  ChartPalette,
  "primarySoft" | "primaryStrong" | "accentSoft" | "neutral" | "neutralStrong"
>;

// --- REFACTORED HOOKS ---

/**
 * A custom hook to manage debounced state updates for chart options, improving performance.
 */
function useDebouncedOptions<T extends object>(
  defaultOptions: T,
  debounceMs: number = 300
): [T, T, (partial: Partial<T>) => void] {
  const [immediateState, setImmediateState] = useState<T>(defaultOptions);
  const [debouncedState, setDebouncedState] = useState<T>(defaultOptions);

  useEffect(() => {
    setImmediateState(defaultOptions);
    setDebouncedState(defaultOptions);
  }, [defaultOptions]);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedState(immediateState);
    }, debounceMs);
    return () => clearTimeout(handler);
  }, [immediateState, debounceMs]);

  const setPendingOptions = useCallback((partial: Partial<T>) => {
    setImmediateState(prev => ({ ...prev, ...partial }));
  }, []);

  return [debouncedState, immediateState, setPendingOptions];
}

/**
 * Manages simple and complex theme modes, providing the final chart configuration and theme.
 */
function useConfigurableChartTheme(chart: ChartResultContent) {
  const {
    baseColor,
    setBaseColor,
    palette: autoPalette,
    seriesKeys: derivedSeriesKeys,
    theme,
    themedConfig: autoGeneratedConfig,
    getSeriesColor,
  } = useChartTheme();

  const [themeMode, setThemeMode] = useState<"simple" | "complex">("simple");
  const [customPalette, setCustomPalette] = useState<CustomPalette>(autoPalette);

  useEffect(() => {
    if (themeMode === "simple") {
      setCustomPalette(autoPalette);
    }
  }, [autoPalette, themeMode]);

  const colorableEntries = useMemo(() => {
    const { chartType, chartData, chartConfig } = chart;
    if (chartType === "pie" || chartType === "radial") {
      return (chartData || []).map((item: any, index: number) => ({
        key: String(item?.name ?? `slice-${index + 1}`),
        label: String(item?.name ?? `Category ${index + 1}`),
      }));
    }
    const configKeys = Object.keys(chartConfig || {});
    if (configKeys.length > 0) {
      return configKeys.map(key => ({ key, label: key }));
    }
    // Derive numeric series keys from data when config is empty
    if (Array.isArray(chartData) && chartData.length > 0) {
      const first = chartData[0] || {};
      const keys = Object.keys(first).filter(k => k !== "name");
      const numericKeys = keys.filter(k => typeof first[k] === "number");
      const finalKeys = numericKeys.length > 0 ? numericKeys : keys;
      return finalKeys.map(key => ({ key, label: key }));
    }
    return [] as Array<{ key: string; label: string }>;
  }, [chart]);

  useEffect(() => {
    if (themeMode === "complex") {
      setCustomPalette(prev => {
        const requiredCount = colorableEntries.length;
        const currentSeries = prev.series || [];
        if (requiredCount <= 0) return { ...prev, series: [] };
        if (currentSeries.length === requiredCount) return prev;

        const base =
          autoPalette.series && autoPalette.series.length > 0
            ? autoPalette.series
            : [autoPalette.primary];

        const newSeries = Array.from({ length: requiredCount }).map(
          (_, i) => currentSeries[i] ?? base[i % base.length]
        );

        return { ...prev, series: newSeries };
      });
    }
  }, [themeMode, colorableEntries, autoPalette.series, autoPalette.primary]);

  const { finalConfig, finalPalette, finalSeriesColors } = useMemo(() => {
    if (themeMode === "simple") {
      const seriesColors = colorableEntries.map((entry, index) => ({
        ...entry,
        color: getSeriesColor(entry.key, index),
      }));
      return {
        finalConfig: autoGeneratedConfig,
        finalPalette: autoPalette,
        finalSeriesColors: seriesColors,
      };
    }

    // Complex Mode
    const { chartType, chartConfig } = chart;
    const fullCustomPalette: ChartPalette = {
      ...customPalette,
      primarySoft: customPalette.primary,
      primaryStrong: customPalette.primary,
      accentSoft: customPalette.accent,
      neutral: customPalette.background,
      neutralStrong: customPalette.grid,
    };

    const configWithCustomColors = { ...chartConfig };
    colorableEntries.forEach((entry, index) => {
      configWithCustomColors[entry.key] = {
        ...configWithCustomColors[entry.key],
        color: customPalette.series[index % customPalette.series.length],
      };
    });

    if (chartType === "pie" || chartType === "radial") {
      // Ensure color list matches visible categories count
      configWithCustomColors.colors = customPalette.series.slice(0, colorableEntries.length);
    }

    const seriesColors = colorableEntries.map((entry, index) => ({
      ...entry,
      color: customPalette.series[index % customPalette.series.length],
    }));

    return {
      finalConfig: configWithCustomColors,
      finalPalette: fullCustomPalette,
      finalSeriesColors: seriesColors,
    };
  }, [
    themeMode,
    autoGeneratedConfig,
    autoPalette,
    customPalette,
    chart,
    colorableEntries,
    getSeriesColor,
  ]);

  const finalThemeForExport = useMemo(() => {
    if (themeMode === "simple") return theme;
    return { ...theme, palette: finalPalette };
  }, [themeMode, theme, finalPalette]);

  const handleCustomColorChange = useCallback(
    (type: keyof CustomPalette, value: string, index?: number) => {
      setCustomPalette(prev => {
        const newPalette = { ...prev };
        const normalizedValue = normalizeHexColor(value);
        if (type === "series" && index !== undefined) {
          const newSeries = [...(prev.series || [])];
          newSeries[index] = normalizedValue;
          newPalette.series = newSeries;
        } else if (type !== "series") {
          (newPalette as any)[type] = normalizedValue;
        }
        return newPalette;
      });
    },
    []
  );

  return {
    themeMode,
    setThemeMode,
    baseColor,
    setBaseColor,
    finalConfig,
    finalPalette,
    finalThemeForExport,
    customPalette,
    handleCustomColorChange,
    finalSeriesColors,
  };
}

// --- HELPER FUNCTIONS ---

function getDefaultOptions(chartType: ChartType): ChartOptionState {
  return {
    barRadius: ENHANCED_CHART_DEFAULTS.bar.radius,
    barShowValues: ENHANCED_CHART_DEFAULTS.bar.showValues,
    barShowGrid: ENHANCED_CHART_DEFAULTS.bar.showGrid,
    lineCurveType: ENHANCED_CHART_DEFAULTS.line.curveType,
    lineShowDots: ENHANCED_CHART_DEFAULTS.line.showDots,
    lineDotSize: ENHANCED_CHART_DEFAULTS.line.dotSize,
    lineDotVariant: ENHANCED_CHART_DEFAULTS.line.dotVariant,
    lineShowGrid: ENHANCED_CHART_DEFAULTS.line.showGrid,
    areaFillOpacity: ENHANCED_CHART_DEFAULTS.fillOpacity,
    areaStacked: ENHANCED_CHART_DEFAULTS.stacked,
    areaUseGradient: ENHANCED_CHART_DEFAULTS.area.useGradient,
    areaShowGrid: ENHANCED_CHART_DEFAULTS.area.showGrid,
    innerRadius: ENHANCED_CHART_DEFAULTS.innerRadius,
    outerRadius: ENHANCED_CHART_DEFAULTS.outerRadius,
    showPercentage: ENHANCED_CHART_DEFAULTS.showPercentage,
    showLegend: ENHANCED_CHART_DEFAULTS.showLegend,
    radialInnerRadius: ENHANCED_CHART_DEFAULTS.radial.innerRadius,
    radialOuterRadius: ENHANCED_CHART_DEFAULTS.radial.outerRadius,
    radialBarSize: ENHANCED_CHART_DEFAULTS.radial.barSize,
    radialCornerRadius: ENHANCED_CHART_DEFAULTS.radial.cornerRadius,
    radialShowBackground: ENHANCED_CHART_DEFAULTS.radial.showBackground,
    radialShowLabels: ENHANCED_CHART_DEFAULTS.radial.showLabels,
    radarShowArea: ENHANCED_CHART_DEFAULTS.radar.showArea,
    radarShowDots: ENHANCED_CHART_DEFAULTS.radar.showDots,
    radarShowGrid: ENHANCED_CHART_DEFAULTS.radar.showGrid,
    radarShowLegend: ENHANCED_CHART_DEFAULTS.radar.showLegend,
    radarFillOpacity: ENHANCED_CHART_DEFAULTS.radar.fillOpacity,
    radarStrokeWidth: ENHANCED_CHART_DEFAULTS.radar.strokeWidth,
  };
}

function getChartTypeLabel(chartType: ChartType): string {
  return CHART_TYPE_LABELS[chartType]?.en || chartType;
}

// --- DECOMPOSED CHILD COMPONENTS ---

const ChartHeader: FC<{
  chart: ChartResultContent;
  isExporting: boolean;
  stage: string;
  progress: number;
  exportError?: string;
  onRetry: () => void;
  onClose: () => void;
}> = memo(({ chart, isExporting, stage, progress, exportError, onRetry, onClose }) => (
  <div className="bg-muted/20 flex items-center justify-between border-b p-4">
    <div className="min-w-0 flex-1">
      <div className="flex items-center gap-2">
        <h2 className="text-foreground truncate text-lg font-semibold">{chart.title}</h2>
        {isExporting && (
          <Badge variant="secondary" className="flex items-center gap-1">
            <div className="h-2 w-2 animate-pulse rounded-full bg-blue-500" />
            {stage} {progress > 0 && `${progress}%`}
          </Badge>
        )}
        {exportError && (
          <Badge variant="destructive" className="flex items-center gap-1">
            <AlertCircle className="h-3 w-3" /> Export failed
          </Badge>
        )}
      </div>
      {chart.description && (
        <p className="text-muted-foreground mt-1 truncate text-sm">{chart.description}</p>
      )}
      {isExporting && progress > 0 && (
        <div className="mt-2">
          <Progress value={progress} className="h-1" />
        </div>
      )}
    </div>
    <div className="ml-4 flex items-center space-x-2">
      {exportError && (
        <Button
          variant="outline"
          size="sm"
          onClick={onRetry}
          className="flex items-center space-x-1"
        >
          <RotateCcw className="h-4 w-4" />
          <span className="hidden sm:inline">Retry</span>
        </Button>
      )}
      <Button
        variant="ghost"
        size="sm"
        onClick={onClose}
        className="text-muted-foreground hover:text-foreground"
      >
        <X className="h-4 w-4" />
      </Button>
    </div>
  </div>
));
ChartHeader.displayName = "ChartHeader";

const ChartRenderer: FC<{
  chart: ChartResultContent;
  chartRef: React.RefObject<HTMLDivElement | null>;
  config: any;
  options: ChartOptionState;
}> = memo(({ chart, chartRef, config, options }) => (
  <div ref={chartRef} className="w-full rounded-lg border p-4">
    <EnhancedChart type={chart.chartType} data={chart.chartData} config={config} {...options} />
  </div>
));
ChartRenderer.displayName = "ChartRenderer";

const ChartFooter: FC<{
  chart: ChartResultContent;
  isExporting: boolean;
  exportError?: string;
}> = memo(({ chart, isExporting, exportError }) => (
  <div className="bg-muted/10 border-t px-4 py-3">
    <div className="text-muted-foreground flex flex-wrap items-center justify-between gap-2 text-xs">
      <div className="flex flex-wrap items-center gap-4">
        <span>Type: {getChartTypeLabel(chart.chartType)}</span>
        <span>Rows: {chart.chartData.length}</span>
        {chart.imageInfo && (
          <span>
            Size: {chart.imageInfo.dimensions.width} × {chart.imageInfo.dimensions.height}
          </span>
        )}
        {isExporting && (
          <span className="flex items-center gap-1">
            <div className="h-2 w-2 animate-pulse rounded-full bg-blue-500" />
            Exporting...
          </span>
        )}
      </div>
      <div className="flex items-center gap-4">
        {exportError && <span className="text-red-500">Export failed: {exportError}</span>}
        <span>
          Generated:{" "}
          {chart.imageInfo?.createdAt
            ? new Date(chart.imageInfo.createdAt).toLocaleTimeString()
            : "just now"}
        </span>
      </div>
    </div>
  </div>
));
ChartFooter.displayName = "ChartFooter";

const ColorChip: FC<{ label: string; color: string; subdued?: boolean }> = ({
  label,
  color,
  subdued,
}) => (
  <span
    className={`flex items-center gap-2 rounded-full border px-2 py-1 text-xs ${subdued ? "border-border/70 bg-muted/40" : "border-border bg-background"}`}
  >
    <span
      className="h-3 w-3 rounded-full border"
      style={{ backgroundColor: color, borderColor: color }}
    />
    <span className="text-muted-foreground">{label}</span>
  </span>
);

const ColorInput: FC<{
  label: string;
  color: string;
  onChange: (color: string) => void;
}> = ({ label, color, onChange }) => (
  <div className="flex items-center gap-2">
    <input
      type="color"
      value={color}
      onChange={e => onChange(e.target.value)}
      className="border-border h-8 w-8 cursor-pointer rounded border"
      aria-label={`Select ${label} color`}
    />
    <Label className="flex-1 text-sm">{label}</Label>
    <Input
      value={color}
      onChange={e => onChange(e.target.value)}
      className="w-20 text-xs"
      pattern={HEX_INPUT_PATTERN.source}
    />
  </div>
);

const ThemeCustomizationPanel: FC<{
  themeMode: "simple" | "complex";
  onThemeModeChange: (mode: "simple" | "complex") => void;
  baseColor: string;
  onBaseColorChange: (color: string) => void;
  palette: ChartPalette;
  customPalette: CustomPalette;
  onCustomColorChange: (type: keyof CustomPalette, value: string, index?: number) => void;
  seriesColors: Array<{ key: string; label: string; color: string }>;
  onRegenerateImage: () => void;
  isRegenerating: boolean;
}> = memo(
  ({
    themeMode,
    onThemeModeChange,
    baseColor,
    onBaseColorChange,
    palette,
    customPalette,
    onCustomColorChange,
    seriesColors,
    onRegenerateImage,
    isRegenerating,
  }) => {
    const [hexInput, setHexInput] = useState(baseColor);
    const [hexError, setHexError] = useState<string | null>(null);

    useEffect(() => {
      setHexInput(baseColor);
    }, [baseColor]);

    const handleHexInputChange = (e: ChangeEvent<HTMLInputElement>) => {
      setHexInput(e.target.value);
      setHexError(null);
      if (HEX_INPUT_PATTERN.test(e.target.value.trim())) {
        onBaseColorChange(normalizeHexColor(e.target.value));
      }
    };

    const applyHexInput = () => {
      if (!HEX_INPUT_PATTERN.test(hexInput.trim())) {
        setHexError("Invalid hex color");
      } else {
        onBaseColorChange(normalizeHexColor(hexInput));
      }
    };

    const palettePreview = [
      { label: "Primary", color: palette.primary },
      { label: "Accent", color: palette.accent },
      { label: "Background", color: palette.background },
      { label: "Grid", color: palette.grid },
    ];

    return (
      <Card className="bg-muted/20">
        <CardContent className="space-y-3 p-3">
          <div className="flex items-center justify-between">
            <Label className="flex items-center gap-2 text-sm font-medium">
              <PaletteIcon className="h-4 w-4" />
              Theme
            </Label>
            <Button
              variant="outline"
              size="sm"
              onClick={onRegenerateImage}
              disabled={isRegenerating}
              className="flex items-center gap-1"
            >
              <RefreshCcw className={`h-4 w-4 ${isRegenerating ? "animate-spin" : ""}`} />
              <span>{isRegenerating ? "Rendering..." : "Regenerate Image"}</span>
            </Button>
          </div>

          <Tabs value={themeMode} onValueChange={v => onThemeModeChange(v as "simple" | "complex")}>
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="simple">Simple</TabsTrigger>
              <TabsTrigger value="complex">Custom</TabsTrigger>
            </TabsList>
            <TabsContent value="simple" className="space-y-3 pt-4">
              <div className="flex flex-wrap items-center gap-3">
                <Label className="text-sm">Base Color</Label>
                <input
                  type="color"
                  value={baseColor}
                  onChange={e => onBaseColorChange(e.target.value)}
                  className="border-border h-9 w-9 cursor-pointer rounded border"
                />
                <Input
                  value={hexInput}
                  onChange={handleHexInputChange}
                  onBlur={applyHexInput}
                  onKeyDown={e => e.key === "Enter" && applyHexInput()}
                  className="w-24"
                  placeholder="#3B82F6"
                />
                {hexError && <span className="text-xs text-red-500">{hexError}</span>}
              </div>
            </TabsContent>
            <TabsContent value="complex" className="space-y-3 pt-4">
              <div className="grid gap-4 md:grid-cols-2">
                <div className="space-y-2">
                  <Label className="text-sm font-medium">Grid</Label>
                  <ColorInput
                    label="Grid"
                    color={customPalette.grid}
                    onChange={v => onCustomColorChange("grid", v)}
                  />
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-medium">Series Colors</Label>
                  <div className="max-h-32 space-y-2 overflow-y-auto pr-2">
                    {(customPalette.series || []).map((color: string, index: number) => (
                      <ColorInput
                        key={index}
                        label={seriesColors[index]?.label || `Series ${index + 1}`}
                        color={color}
                        onChange={v => onCustomColorChange("series", v, index)}
                      />
                    ))}
                  </div>
                </div>
              </div>
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
    );
  }
);
ThemeCustomizationPanel.displayName = "ThemeCustomizationPanel";

const ChartOptionsPanel: FC<{
  chart: ChartResultContent;
  options: ChartOptionState;
  onOptionChange: (partial: Partial<ChartOptionState>) => void;
}> = memo(({ chart, options, onOptionChange }) => {
  const { chartType } = chart;

  const renderControls = () => {
    switch (chartType) {
      case "bar":
        return (
          <div className="grid gap-4 md:grid-cols-2">
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Bar Styling</Label>
                <div className="flex items-center gap-3">
                  <Label className="text-muted-foreground text-sm">Radius</Label>
                  <Slider
                    value={[options.barRadius ?? 0]}
                    min={0}
                    max={BAR_RADIUS_MAX}
                    step={1}
                    onValueChange={v => onOptionChange({ barRadius: v[0] })}
                  />
                  <span className="text-muted-foreground w-8 text-xs">
                    {(options.barRadius ?? 0).toFixed(0)}px
                  </span>
                </div>
              </CardContent>
            </Card>
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Display</Label>
                <div className="flex items-center gap-2">
                  <Switch
                    id="bar-values"
                    checked={options.barShowValues}
                    onCheckedChange={v => onOptionChange({ barShowValues: v })}
                  />
                  <Label htmlFor="bar-values" className="text-muted-foreground text-sm">
                    Show value labels
                  </Label>
                </div>
                <div className="flex items-center gap-2">
                  <Switch
                    id="bar-grid"
                    checked={options.barShowGrid}
                    onCheckedChange={v => onOptionChange({ barShowGrid: v })}
                  />
                  <Label htmlFor="bar-grid" className="text-muted-foreground text-sm">
                    Show grid
                  </Label>
                </div>
              </CardContent>
            </Card>
          </div>
        );
      case "line":
        return (
          <div className="grid gap-4 md:grid-cols-3">
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Line Style</Label>
                <div className="flex items-center gap-2">
                  <Switch
                    id="line-smooth"
                    checked={options.lineCurveType !== "linear"}
                    onCheckedChange={v =>
                      onOptionChange({ lineCurveType: v ? "monotone" : "linear" })
                    }
                  />
                  <Label htmlFor="line-smooth" className="text-muted-foreground text-sm">
                    Smooth curve
                  </Label>
                </div>
              </CardContent>
            </Card>
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Points</Label>
                <div className="flex items-center gap-2">
                  <Switch
                    id="line-dots"
                    checked={options.lineShowDots}
                    onCheckedChange={v => onOptionChange({ lineShowDots: v })}
                  />
                  <Label htmlFor="line-dots" className="text-muted-foreground text-sm">
                    Show points
                  </Label>
                </div>
                <Select
                  value={options.lineDotVariant}
                  onValueChange={(v: LineDotVariant) => onOptionChange({ lineDotVariant: v })}
                  disabled={!options.lineShowDots}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Point Style" />
                  </SelectTrigger>
                  <SelectContent>
                    {LINE_DOT_VARIANTS.map(o => (
                      <SelectItem key={o.value} value={o.value}>
                        {o.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </CardContent>
            </Card>
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Display</Label>
                <div className="flex items-center gap-2">
                  <Switch
                    id="line-grid"
                    checked={options.lineShowGrid}
                    onCheckedChange={v => onOptionChange({ lineShowGrid: v })}
                  />
                  <Label htmlFor="line-grid" className="text-muted-foreground text-sm">
                    Show grid
                  </Label>
                </div>
              </CardContent>
            </Card>
          </div>
        );
      case "area":
        return (
          <div className="grid gap-4 md:grid-cols-2">
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Area Style</Label>
                <div className="flex items-center gap-2">
                  <Switch
                    id="area-stacked"
                    checked={options.areaStacked}
                    onCheckedChange={v => onOptionChange({ areaStacked: v })}
                  />
                  <Label htmlFor="area-stacked" className="text-muted-foreground text-sm">
                    Stacked
                  </Label>
                </div>
                <div className="flex items-center gap-2">
                  <Switch
                    id="area-gradient"
                    checked={options.areaUseGradient}
                    onCheckedChange={v => onOptionChange({ areaUseGradient: v })}
                  />
                  <Label htmlFor="area-gradient" className="text-muted-foreground text-sm">
                    Use gradient
                  </Label>
                </div>
              </CardContent>
            </Card>
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Fill Opacity</Label>
                <div className="flex items-center gap-3">
                  <Slider
                    value={[options.areaFillOpacity ?? 0.6]}
                    min={0.1}
                    max={1}
                    step={0.05}
                    onValueChange={v => onOptionChange({ areaFillOpacity: v[0] })}
                  />
                  <span className="text-muted-foreground w-8 text-xs">
                    {Math.round((options.areaFillOpacity ?? 0.6) * 100)}%
                  </span>
                </div>
              </CardContent>
            </Card>
          </div>
        );
      case "pie":
        return (
          <div className="grid gap-4 md:grid-cols-2">
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Sizing</Label>
                <div className="flex items-center gap-3">
                  <Label className="text-muted-foreground text-sm">Inner Radius</Label>
                  <Slider
                    value={[options.innerRadius ?? 0]}
                    min={0}
                    max={90}
                    step={5}
                    onValueChange={v => onOptionChange({ innerRadius: v[0] })}
                  />
                  <span className="text-muted-foreground w-8 text-xs">
                    {options.innerRadius ?? 0}px
                  </span>
                </div>
              </CardContent>
            </Card>
            <Card className="bg-muted/20">
              <CardContent className="space-y-3 p-4">
                <Label className="text-sm font-medium">Display</Label>
                <div className="flex items-center gap-2">
                  <Switch
                    id="pie-legend"
                    checked={options.showLegend}
                    onCheckedChange={v => onOptionChange({ showLegend: v })}
                  />
                  <Label htmlFor="pie-legend" className="text-muted-foreground text-sm">
                    Show legend
                  </Label>
                </div>
                <div className="flex items-center gap-2">
                  <Switch
                    id="pie-percentage"
                    checked={options.showPercentage}
                    onCheckedChange={v => onOptionChange({ showPercentage: v })}
                  />
                  <Label htmlFor="pie-percentage" className="text-muted-foreground text-sm">
                    Show percentage
                  </Label>
                </div>
              </CardContent>
            </Card>
          </div>
        );
      default:
        return null;
    }
  };

  const controls = renderControls();
  if (!controls) return null;

  return (
    <Card className="bg-muted/20">
      <CardContent className="p-3">
        <Label className="mb-4 block text-sm font-medium">Chart Options</Label>
        {controls}
      </CardContent>
    </Card>
  );
});
ChartOptionsPanel.displayName = "ChartOptionsPanel";

// --- MAIN COMPONENTS ---

function ThemedChartContent({
  chart,
  chartRef,
  chartId,
  onClose,
  isExporting,
  stage,
  progress,
  exportError,
  onRetry,
  onUpdateChart,
}: Omit<ThemedChartContentProps, "isRegenerating" | "setIsRegenerating">) {
  const { toast } = useToast();
  const [isRegenerating, setIsRegenerating] = useState(false);

  const {
    themeMode,
    setThemeMode,
    baseColor,
    setBaseColor,
    finalConfig,
    finalPalette,
    finalThemeForExport,
    customPalette,
    handleCustomColorChange,
    finalSeriesColors,
  } = useConfigurableChartTheme(chart);

  const defaultOptions = useMemo(() => getDefaultOptions(chart.chartType), [chart.chartType]);
  const [debouncedOptions, pendingOptions, setPendingOptions] = useDebouncedOptions(defaultOptions);

  const handleRegenerateImage = useCallback(async () => {
    if (!chartRef.current || isRegenerating) return;
    setIsRegenerating(true);

    try {
      await new Promise(resolve => setTimeout(resolve, 150)); // Wait for render updates
      const exportId = `${chartId}_theme_${Date.now()}`;
      const result = await chartExportService.exportChart(chartRef.current, exportId, chart.title);

      if (!result.success) throw new Error(result.error);

      const updatedChart: ChartResultContent = {
        ...chart,
        imageInfo: {
          filename: result.filename,
          localBlobUrl: result.blobUrl,
          size: result.size,
          format: "png",
          dimensions: result.dimensions,
          createdAt: new Date(),
          metadata: { ...chart.imageInfo?.metadata, exportMethod: "theme-regenerate" },
        },
        chartConfig: { ...finalConfig, ...debouncedOptions },
        theme: finalThemeForExport,
      };

      onUpdateChart?.(updatedChart);
      globalChartManager.appendChart(updatedChart);
      toast({
        title: "Chart updated",
        description: "A new version with the updated theme has been added.",
      });
    } catch (error) {
      console.error("❌ [ChartDisplayArea] Failed to regenerate export:", error);
      toast({
        title: "Regeneration failed",
        description: error instanceof Error ? error.message : "Unknown error",
        variant: "destructive",
      });
    } finally {
      setIsRegenerating(false);
    }
  }, [
    chart,
    chartId,
    chartRef,
    isRegenerating,
    finalConfig,
    debouncedOptions,
    finalThemeForExport,
    onUpdateChart,
    toast,
  ]);

  return (
    <div className="bg-background flex h-full flex-col overflow-auto">
      <ChartHeader
        chart={chart}
        isExporting={isExporting}
        stage={stage}
        progress={progress}
        exportError={exportError}
        onRetry={onRetry}
        onClose={onClose}
      />

      <div className="flex-1 p-4 md:p-6">
        <ChartThemeProvider
          chartType={chart.chartType}
          chartData={chart.chartData}
          chartConfig={finalConfig}
          theme={finalThemeForExport}
        >
          <ChartRenderer
            chart={chart}
            chartRef={chartRef}
            config={finalConfig}
            options={debouncedOptions}
          />
        </ChartThemeProvider>
      </div>

      <div className="grid gap-3 border-t p-3 md:grid-cols-2">
        <ThemeCustomizationPanel
          themeMode={themeMode}
          onThemeModeChange={setThemeMode}
          baseColor={baseColor}
          onBaseColorChange={setBaseColor}
          palette={finalPalette}
          customPalette={customPalette}
          onCustomColorChange={handleCustomColorChange}
          seriesColors={finalSeriesColors}
          onRegenerateImage={handleRegenerateImage}
          isRegenerating={isRegenerating}
        />
        <ChartOptionsPanel
          chart={chart}
          options={pendingOptions}
          onOptionChange={setPendingOptions}
        />
      </div>

      <ChartFooter chart={chart} isExporting={isExporting} exportError={exportError} />
    </div>
  );
}

interface ThemedChartContentProps {
  chart: ChartResultContent;
  chartRef: React.RefObject<HTMLDivElement | null>;
  chartId: string;
  onClose: () => void;
  isExporting: boolean;
  stage: string;
  progress: number;
  exportError?: string;
  onRetry: () => void;
  onUpdateChart?: (chart: ChartResultContent) => void;
}

export function ChartDisplayArea({ chart, onClose, onUpdateChart }: ChartDisplayAreaProps) {
  const chartRef = useRef<HTMLDivElement>(null);
  const { registerChart } = useChartExport();
  const chartId = useMemo(
    () =>
      chart
        ? `${chart.title.replace(/[^a-zA-Z0-9]/g, "_")}_${chart.chartType}_${chart.chartData.length}`
        : "",
    [chart]
  );
  const { isExporting, progress, stage, error, retry } = useChartExportStatus(chartId);

  useEffect(() => {
    if (chart && chartRef.current && chartId && !chart.imageInfo?.localBlobUrl) {
      const timer = setTimeout(() => {
        if (chartRef.current) {
          registerChart(chartId, chartRef.current, chart);
        }
      }, 800);
      return () => clearTimeout(timer);
    }
  }, [chart, chartId, registerChart]);

  if (!chart) {
    return (
      <div className="flex h-full items-center justify-center p-8">
        <div className="space-y-3 text-center">
          <div className="bg-muted mx-auto flex h-16 w-16 items-center justify-center rounded-full">
            <svg
              className="text-muted-foreground h-8 w-8"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={1.5}
                d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
              />
            </svg>
          </div>
          <h3 className="text-muted-foreground text-lg font-semibold">Waiting for chart</h3>
          <p className="text-muted-foreground text-sm">The generated chart will appear here.</p>
        </div>
      </div>
    );
  }

  return (
    <ChartThemeProvider
      chartType={chart.chartType}
      chartData={chart.chartData}
      chartConfig={chart.chartConfig}
      theme={chart.theme}
    >
      <ThemedChartContent
        chart={chart}
        chartRef={chartRef}
        chartId={chartId}
        onClose={onClose}
        isExporting={isExporting}
        stage={stage}
        progress={progress}
        exportError={error}
        onRetry={retry}
        onUpdateChart={onUpdateChart}
      />
    </ChartThemeProvider>
  );
}
